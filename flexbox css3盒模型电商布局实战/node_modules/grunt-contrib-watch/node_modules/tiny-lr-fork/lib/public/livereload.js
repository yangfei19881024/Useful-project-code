(function() {
var __customevents = {}, __protocol = {}, __connector = {}, __timer = {}, __options = {}, __reloader = {}, __livereload = {}, __less = {}, __startup = {};

// customevents
var CustomEvents;
CustomEvents = {
  bind: function(element, eventName, handler) {
    if (element.addEventListener) {
      return element.addEventListener(eventName, handler, false);
    } else if (element.attachEvent) {
      element[eventName] = 1;
      return element.attachEvent('onpropertychange', function(event) {
        if (event.propertyName === eventName) {
          return handler();
        }
      });
    } else {
      throw new Error("Attempt to attach custom event " + eventName + " to something which isn't a DOMElement");
    }
  },
  fire: function(element, eventName) {
    var event;
    if (element.addEventListener) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      return document.dispatchEvent(event);
    } else if (element.attachEvent) {
      if (element[eventName]) {
        return element[eventName]++;
      }
    } else {
      throw new Error("Attempt to fire custom event " + eventName + " on something which isn't a DOMElement");
    }
  }
};
__customevents.bind = CustomEvents.bind;
__customevents.fire = CustomEvents.fire;

// protocol
var PROTOCOL_6, PROTOCOL_7, Parser, ProtocolError;
var __indexOf = Array.prototype.indexOf || function(item) {
  for (var i = 0, l = this.length; i < l; i++) {
    if (this[i] === item) return i;
  }
  return -1;
};
__protocol.PROTOCOL_6 = PROTOCOL_6 = 'http://livereload.com/protocols/official-6';
__protocol.PROTOCOL_7 = PROTOCOL_7 = 'http://livereload.com/protocols/official-7';
__protocol.ProtocolError = ProtocolError = (function() {
  function ProtocolError(reason, data) {
    this.message = "LiveReload protocol error (" + reason + ") after receiving data: \"" + data + "\".";
  }
  return ProtocolError;
})();
__protocol.Parser = Parser = (function() {
  function Parser(handlers) {
    this.handlers = handlers;
    this.reset();
  }
  Parser.prototype.reset = function() {
    return this.protocol = null;
  };
  Parser.prototype.process = function(data) {
    var command, message, options, _ref;
    try {
      if (!(this.protocol != null)) {
        if (data.match(/^!!ver:([\d.]+)$/)) {
          this.protocol = 6;
        } else if (message = this._parseMessage(data, ['hello'])) {
          if (!message.protocols.length) {
            throw new ProtocolError("no protocols specified in handshake message");
          } else if (__indexOf.call(message.protocols, PROTOCOL_7) >= 0) {
            this.protocol = 7;
          } else if (__indexOf.call(message.protocols, PROTOCOL_6) >= 0) {
            this.protocol = 6;
          } else {
            throw new ProtocolError("no supported protocols found");
          }
        }
        return this.handlers.connected(this.protocol);
      } else if (this.protocol === 6) {
        message = JSON.parse(data);
        if (!message.length) {
          throw new ProtocolError("protocol 6 messages must be arrays");
        }
        command = message[0], options = message[1];
        if (command !== 'refresh') {
          throw new ProtocolError("unknown protocol 6 command");
        }
        return this.handlers.message({
          command: 'reload',
          path: options.path,
          liveCSS: (_ref = options.apply_css_live) != null ? _ref : true
        });
      } else {
        message = this._parseMessage(data, ['reload', 'alert']);
        return this.handlers.message(message);
      }
    } catch (e) {
      if (e instanceof ProtocolError) {
        return this.handlers.error(e);
      } else {
        throw e;
      }
    }
  };
  Parser.prototype._parseMessage = function(data, validCommands) {
    var message, _ref;
    try {
      message = JSON.parse(data);
    } catch (e) {
      throw new ProtocolError('unparsable JSON', data);
    }
    if (!message.command) {
      throw new ProtocolError('missing "command" key', data);
    }
    if (_ref = message.command, __indexOf.call(validCommands, _ref) < 0) {
      throw new ProtocolError("invalid command '" + message.command + "', only valid commands are: " + (validCommands.join(', ')) + ")", data);
    }
    return message;
  };
  return Parser;
})();

// connector
// Generated by CoffeeScript 1.3.3
var Connector, PROTOCOL_6, PROTOCOL_7, Parser, Version, _ref;

_ref = __protocol, Parser = _ref.Parser, PROTOCOL_6 = _ref.PROTOCOL_6, PROTOCOL_7 = _ref.PROTOCOL_7;

Version = '2.0.8';

__connector.Connector = Connector = (function() {

  function Connector(options, WebSocket, Timer, handlers) {
    var _this = this;
    this.options = options;
    this.WebSocket = WebSocket;
    this.Timer = Timer;
    this.handlers = handlers;
    this._uri = "ws" + (this.options.https ? "s" : "") + "://" + this.options.host + ":" + this.options.port + "/livereload";
    this._nextDelay = this.options.mindelay;
    this._connectionDesired = false;
    this.protocol = 0;
    this.protocolParser = new Parser({
      connected: function(protocol) {
        _this.protocol = protocol;
        _this._handshakeTimeout.stop();
        _this._nextDelay = _this.options.mindelay;
        _this._disconnectionReason = 'broken';
        return _this.handlers.connected(protocol);
      },
      error: function(e) {
        _this.handlers.error(e);
        return _this._closeOnError();
      },
      message: function(message) {
        return _this.handlers.message(message);
      }
    });
    this._handshakeTimeout = new Timer(function() {
      if (!_this._isSocketConnected()) {
        return;
      }
      _this._disconnectionReason = 'handshake-timeout';
      return _this.socket.close();
    });
    this._reconnectTimer = new Timer(function() {
      if (!_this._connectionDesired) {
        return;
      }
      return _this.connect();
    });
    this.connect();
  }

  Connector.prototype._isSocketConnected = function() {
    return this.socket && this.socket.readyState === this.WebSocket.OPEN;
  };

  Connector.prototype.connect = function() {
    var _this = this;
    this._connectionDesired = true;
    if (this._isSocketConnected()) {
      return;
    }
    this._reconnectTimer.stop();
    this._disconnectionReason = 'cannot-connect';
    this.protocolParser.reset();
    this.handlers.connecting();
    this.socket = new this.WebSocket(this._uri);
    this.socket.onopen = function(e) {
      return _this._onopen(e);
    };
    this.socket.onclose = function(e) {
      return _this._onclose(e);
    };
    this.socket.onmessage = function(e) {
      return _this._onmessage(e);
    };
    return this.socket.onerror = function(e) {
      return _this._onerror(e);
    };
  };

  Connector.prototype.disconnect = function() {
    this._connectionDesired = false;
    this._reconnectTimer.stop();
    if (!this._isSocketConnected()) {
      return;
    }
    this._disconnectionReason = 'manual';
    return this.socket.close();
  };

  Connector.prototype._scheduleReconnection = function() {
    if (!this._connectionDesired) {
      return;
    }
    if (!this._reconnectTimer.running) {
      this._reconnectTimer.start(this._nextDelay);
      return this._nextDelay = Math.min(this.options.maxdelay, this._nextDelay * 2);
    }
  };

  Connector.prototype.sendCommand = function(command) {
    if (this.protocol == null) {
      return;
    }
    return this._sendCommand(command);
  };

  Connector.prototype._sendCommand = function(command) {
    return this.socket.send(JSON.stringify(command));
  };

  Connector.prototype._closeOnError = function() {
    this._handshakeTimeout.stop();
    this._disconnectionReason = 'error';
    return this.socket.close();
  };

  Connector.prototype._onopen = function(e) {
    var hello;
    this.handlers.socketConnected();
    this._disconnectionReason = 'handshake-failed';
    hello = {
      command: 'hello',
      protocols: [PROTOCOL_6, PROTOCOL_7]
    };
    hello.ver = Version;
    if (this.options.ext) {
      hello.ext = this.options.ext;
    }
    if (this.options.extver) {
      hello.extver = this.options.extver;
    }
    if (this.options.snipver) {
      hello.snipver = this.options.snipver;
    }
    this._sendCommand(hello);
    return this._handshakeTimeout.start(this.options.handshake_timeout);
  };

  Connector.prototype._onclose = function(e) {
    this.protocol = 0;
    this.handlers.disconnected(this._disconnectionReason, this._nextDelay);
    return this._scheduleReconnection();
  };

  Connector.prototype._onerror = function(e) {};

  Connector.prototype._onmessage = function(e) {
    return this.protocolParser.process(e.data);
  };

  return Connector;

})();

// timer
var Timer;
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
__timer.Timer = Timer = (function() {
  function Timer(func) {
    this.func = func;
    this.running = false;
    this.id = null;
    this._handler = __bind(function() {
      this.running = false;
      this.id = null;
      return this.func();
    }, this);
  }
  Timer.prototype.start = function(timeout) {
    if (this.running) {
      clearTimeout(this.id);
    }
    this.id = setTimeout(this._handler, timeout);
    return this.running = true;
  };
  Timer.prototype.stop = function() {
    if (this.running) {
      clearTimeout(this.id);
      this.running = false;
      return this.id = null;
    }
  };
  return Timer;
})();
Timer.start = function(timeout, func) {
  return setTimeout(func, timeout);
};

// options
var Options;
__options.Options = Options = (function() {
  function Options() {
    this.https = false;
    this.host = null;
    this.port = 35729;
    this.snipver = null;
    this.ext = null;
    this.extver = null;
    this.mindelay = 1000;
    this.maxdelay = 60000;
    this.handshake_timeout = 5000;
  }
  Options.prototype.set = function(name, value) {
    switch (typeof this[name]) {
      case 'undefined':
        break;
      case 'number':
        return this[name] = +value;
      default:
        return this[name] = value;
    }
  };
  return Options;
})();
Options.extract = function(document) {
  var element, keyAndValue, m, mm, options, pair, src, _i, _j, _len, _len2, _ref, _ref2;
  _ref = document.getElementsByTagName('script');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    element = _ref[_i];
    if ((src = element.src) && (m = src.match(/^[^:]+:\/\/(.*)\/z?livereload\.js(?:\?(.*))?$/))) {
      options = new Options();
      options.https = src.indexOf("https") === 0;
      if (mm = m[1].match(/^([^\/:]+)(?::(\d+))?$/)) {
        options.host = mm[1];
        if (mm[2]) {
          options.port = parseInt(mm[2], 10);
        }
      }
      if (m[2]) {
        _ref2 = m[2].split('&');
        for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
          pair = _ref2[_j];
          if ((keyAndValue = pair.split('=')).length > 1) {
            options.set(keyAndValue[0].replace(/-/g, '_'), keyAndValue.slice(1).join('='));
          }
        }
      }
      return options;
    }
  }
  return null;
};

// reloader
// Generated by CoffeeScript 1.3.1
(function() {
  var IMAGE_STYLES, Reloader, numberOfMatchingSegments, pathFromUrl, pathsMatch, pickBestMatch, splitUrl;

  splitUrl = function(url) {
    var hash, index, params;
    if ((index = url.indexOf('#')) >= 0) {
      hash = url.slice(index);
      url = url.slice(0, index);
    } else {
      hash = '';
    }
    if ((index = url.indexOf('?')) >= 0) {
      params = url.slice(index);
      url = url.slice(0, index);
    } else {
      params = '';
    }
    return {
      url: url,
      params: params,
      hash: hash
    };
  };

  pathFromUrl = function(url) {
    var path;
    url = splitUrl(url).url;
    if (url.indexOf('file://') === 0) {
      path = url.replace(/^file:\/\/(localhost)?/, '');
    } else {
      path = url.replace(/^([^:]+:)?\/\/([^:\/]+)(:\d*)?\//, '/');
    }
    return decodeURIComponent(path);
  };

  pickBestMatch = function(path, objects, pathFunc) {
    var bestMatch, object, score, _i, _len;
    bestMatch = {
      score: 0
    };
    for (_i = 0, _len = objects.length; _i < _len; _i++) {
      object = objects[_i];
      score = numberOfMatchingSegments(path, pathFunc(object));
      if (score > bestMatch.score) {
        bestMatch = {
          object: object,
          score: score
        };
      }
    }
    if (bestMatch.score > 0) {
      return bestMatch;
    } else {
      return null;
    }
  };

  numberOfMatchingSegments = function(path1, path2) {
    var comps1, comps2, eqCount, len;
    
    // normalize windows paths
    path1 = path1.replace(/\\/g,'\/');
    path2 = path2.replace(/\\/g,'\/');
    
    path1 = path1.replace(/^\/+/, '').toLowerCase();
    path2 = path2.replace(/^\/+/, '').toLowerCase();
    if (path1 === path2) {
      return 10000;
    }
    comps1 = path1.split('/').reverse();
    comps2 = path2.split('/').reverse();
    len = Math.min(comps1.length, comps2.length);
    eqCount = 0;
    while (eqCount < len && comps1[eqCount] === comps2[eqCount]) {
      ++eqCount;
    }
    return eqCount;
  };

  pathsMatch = function(path1, path2) {
    return numberOfMatchingSegments(path1, path2) > 0;
  };

  IMAGE_STYLES = [
    {
      selector: 'background',
      styleNames: ['backgroundImage']
    }, {
      selector: 'border',
      styleNames: ['borderImage', 'webkitBorderImage', 'MozBorderImage']
    }
  ];

  __reloader.Reloader = Reloader = (function() {

    Reloader.name = 'Reloader';

    function Reloader(window, console, Timer) {
      this.window = window;
      this.console = console;
      this.Timer = Timer;
      this.document = this.window.document;
      this.importCacheWaitPeriod = 200;
      this.plugins = [];
    }

    Reloader.prototype.addPlugin = function(plugin) {
      return this.plugins.push(plugin);
    };

    Reloader.prototype.analyze = function(callback) {
      return results;
    };

    Reloader.prototype.reload = function(path, options) {
      var plugin, _base, _i, _len, _ref;
      this.options = options;
      if ((_base = this.options).stylesheetReloadTimeout == null) {
        _base.stylesheetReloadTimeout = 15000;
      }
      _ref = this.plugins;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        plugin = _ref[_i];
        if (plugin.reload && plugin.reload(path, options)) {
          return;
        }
      }
      if (options.liveCSS) {
        if (path.match(/\.css$/i)) {
          if (this.reloadStylesheet(path)) {
            return;
          }
        }
      }
      if (options.liveImg) {
        if (path.match(/\.(jpe?g|png|gif)$/i)) {
          this.reloadImages(path);
          return;
        }
      }
      return this.reloadPage();
    };

    Reloader.prot